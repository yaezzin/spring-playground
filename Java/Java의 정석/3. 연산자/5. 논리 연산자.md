# 논리 연산자

## 논리 연산자 && || !

|x   |y    |x ll y | x && y|
|----|-----|-------|-------|
|0  |0     |F      | F     |
|0  |1     |T      | F     |
|1  |0     |T      | F     |
|1  |1     |T      | T     |

* 논리 연산자의 특징은 효율적인 연산을 한다는 것이다
* or 연산자의 경우 어느 한쪽만 참이여도 참이므로 연산결과가 참일 확률이 높은 피연산자를 왼쪽에 넣어야 더 빠른 연산결과를 얻을 수 있다
* and 연산자의 경우 어느 한쪽만 거짓이여도 전체 연산결과가 거짓이므로, 좌측 피연산자가 거짓이면 우측 피연산자의 값은 평가 하지 않는다

#### case 1) x는 10보다 크고 20 보다 작다

* 10 < x < 20 으로 표현하는 것을 허용하지 않는다!
 
``` java
x > 10 && x < 20
```

#### case 2) i는 2의 배수 또는 3의 배수이다

```java
i % 2 == 0 || i % 3 == 0
```

#### case 3) i는 2의 배수 또는 3의 배수이나 6의 배수는 아니다
```java
(i % 2 == 0 || i % 3 == 0) && (i % 6 != 0)
```

#### case 4) 문자 ch는 숫자('0' ~ '9')이다
```java
'0' <= ch && ch <= '9'
```

#### case 5) 문자 ch는 대문자 또는 소문자이다.
```java
('a' <= ch && ch <= 'z') || ('A' <=ch && ch <= 'Z')
```


## 비트 연산자 & | ^ ~ << >>

### & | ^

|x   |y    |x l y  | x & y | x ^ y |
|----|-----|-------|-------|-------|
|0   |0    |F      | F     | F     | 
|0   |1    |T      | F     | T     |
|1   |0    |T      | F     | T     |
|1   |1    |T      | T     | F     |

* ```| (or)```  : 피연산자 중 한 쪽 값이 1이면 1을 결과를 얻음  
* ```& (and)``` : 피연산자 양 쪽이 모두 1이여야만 1을 결과로 얻음
* ```^ (xor)``` : 피연산자 값이 서로 다를 때만 1을 결과로 얻음

### 비트 전환 연산자 ~
* 피연산자를 2진수로 표현했을 때, 0은 1로 1은 0으로 바꿈
* 즉 피연산자의 1의 보수를 얻을 수 있음

### 쉬프트 연산자 << >>

1) 10진수 8은 2진수로 00001000

|0|0|0|0|1|0|0|0|
|-|-|-|-|-|-|-|-|

2) 8 << 2 는 10진수 8의 2진수를 왼쪽으로 2자리 이동시킴
* 결국 8 << 2의 결과는 32

|0 0(버려짐)|0|0|1|0|0|0|0|0|
|--|-|-|-|-|-|-|-|--|

3) 결론
* x << n 은 x * 2^n 의 결과와 같음
* x >> n x / 2^n의 
