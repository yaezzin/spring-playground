# java.time 패키지

Java의 탄생과 함께한 Date와 Calendar의 단점을 해소하기 위해 JDK 1.8부터 java.time 패키지가 추가

* ```java.time``` - 날짜와 시간을 다루는데 필요한 핵심 클래스들 제공
* ```java.time.chrono``` - 표준(ISO)이 아닌 달력 시스템을 위한 클래스들 제공
* ```java.time.format``` - 날짜와 시간을 파싱, 형식화하기 위한 클래스들 제공
* ```java.time.temporal``` - 날짜와 시간의 필드와 단위(unit)을 위한 클래스들 제공
* ```java.time.zone``` - 시간대(time-zone)와 관련된 클래스들 제공

위 패키지의 클래스들은 String 클래스처럼 ```불변(Immutable)```
* 즉, 날짜나 시간을 변경하면 기존의 객체가 변경되는 것이 아니라, 새로운 객체를 반환
* (기존의 Calendar 클래스는 변경가능 하므로 멀티쓰레드 환경에서 안전하지 않았음)

## java.time패키지의 핵심 클래스

java.time 패키지에는 날짜와 시간을 별도의 클래스로 분리해 놓았음  
* 시간을 표현할 때는 ```LocalTime``` 클래스를, ```LocalDate``` 클래스를 사용  
* 날짜와 시간 모두 필요할때는 ```LocalDateTime``` 클래스를 사용
* 시간대(time-zone)까지 표현하려면 ```ZonedDateTime```사용

### 타임스탬프(time-stamp)

날짜와 시간을 초단위로 표현한 값.
이 값은 날짜와 시간을 하나의 정수로 표현할 수 있어서 날짜와 시간의 차이를 계산하거나 순서를 비교하는데 유리하다. (그래서 데이터베이스에서 많이 사용)

### 객체 생성하기 - now(), of()

```now()```는 현재 날짜와 시간을 저장하는 객체를 생성
```java
LocalDate date = LocalDate.now();
LocalTime time = LocalTime.now();
```

```of()```는 해당 필드의 값을 순서대로 지정해주면 객체를 생성
```java
LocalDate date = LocalDate.of(2022, 04, 06); 
LocalTime time = LocalTime.of(23, 59, 59); // 23시 59분 59초
```

## LocalDate와 LocalTime

### 🤖 특정 필드의 값 가져오기 - get(), getXXX()

#### 📌 매서드 목록
![image](https://user-images.githubusercontent.com/97823928/161956393-35516d5e-02fd-4e93-8e80-136e3150c088.png)

#### 📌 매개변수 목록
<img width="500" alt="스크린샷 2022-04-06 오후 7 37 42" src="https://user-images.githubusercontent.com/97823928/161956759-e6e2f06e-1e42-412e-aa11-2780cf2d42e4.png">

### 🤖 필드의 값 변경하기 - with(), plus(), minus()

날짜와 시간에서 특정 필드값을 변경하려면 with로 시작하는 메서드를 사용하자!

#### 종류

```java
LocalDate withYear(int year)  
LocalDate withMonth(int month)  
LocalDate withDayOfMonth(int dayOfMonth)  
LocalDate withDayOfYear(int dayOfYear)  

LocalTime withHour(int hour)  
LocalTime withMinute(int minute)  
LocalTime withSecond(int second)  
LocalTime withNano(int nanoOfSecond)
```

#### 새로운 객체 생성
```java
date = date.withYear(2022); // 년도를 2022년으로 변경
time = time.withHour(12); // 시간을 12시로 변경
```

* 필드를 변경하는 메소드들은 항상 새로운 객체를 생성해서 반환하므로 대입연산자를 같이 사용

#### 필드를 0으로 만들기

```java
LocalTime time = LocalTime.of(12, 34, 56); // 12시 34분 56초
time = time.truncatedTo(ChronoUnit.HOURS); // 시(hour)보다 작은 단위를 0
System.out.println(time); // 12:00
```
* LocalTime의 ```truncatedTo()```는 지정된 것보다 작은 단위의 필드를 0으로 만듦

### 🤖 날짜와 시간의 비교 - isAfter(), isBefore(), isEquals()

LocalDate, LocalTime 모두 compareTo()가 적절히 오버라이딩 되어있어서 비교를 할 수 있음

```java
int result = date1.compareTo(date2);
// 같으면 0, date1이 이전이면 -1, 이후면 1
```

하지만 더 편리하게 비교할 수 있는 메서드들이 추가로 제공됨

```java
boolean isAfter (ChronoLocalDate other)
boolean isBefore (ChronoLocalDate other)
boolean isEqual (ChronoLocalDate other)
```

equals()가 있음에도 isEquals()를 추가로 제공하는 이유는 ```연표```가 다른 두 날짜를 비교하기 위해서임!
* 모든 필드가 일치해야하는 equals와 달리 isEquals()는 오직 날짜만 비교!
```java
LocalDate kDate = LocalDate.of(1999, 12, 31);
JapaneseDate jDate = JapaneseDate.of(1999, 12, 31);

System.out.println(kDate.equals(jDate));	//false 연대가 다름
System.out.println(kDate.isEqual(jDate));	//true
```

## Instant

